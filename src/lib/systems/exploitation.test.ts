/**
 * Tests for Exploitation Abilities System
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { createInitialGameState } from '$lib/game/config';
import {
	getAbility,
	calculateAbilityCost,
	canUseAbility,
	useAbility,
	processBoosts,
	getBoostMultiplier,
	getActiveBoosts,
	EXPLOITATION_ABILITIES
} from './exploitation';
import type { GameState } from '$lib/game/types';

describe('Exploitation Abilities System', () => {
	let state: GameState;

	beforeEach(() => {
		state = createInitialGameState();
		state.money = 100000;

		// Reset times used
		for (const ability of EXPLOITATION_ABILITIES) {
			ability.timesUsed = 0;
		}
	});

	describe('getAbility', () => {
		it('should return ability by ID', () => {
			const ability = getAbility('bot_streams');
			expect(ability).toBeDefined();
			expect(ability!.id).toBe('bot_streams');
		});

		it('should return undefined for invalid ID', () => {
			const ability = getAbility('invalid');
			expect(ability).toBeUndefined();
		});
	});

	describe('calculateAbilityCost', () => {
		it('should return base cost for first use', () => {
			const ability = getAbility('bot_streams')!;
			const cost = calculateAbilityCost(ability, 0);
			expect(cost).toBe(ability.baseCost);
		});

		it('should scale cost with uses', () => {
			const ability = getAbility('bot_streams')!;
			const cost1 = calculateAbilityCost(ability, 0);
			const cost2 = calculateAbilityCost(ability, 1);
			expect(cost2).toBeGreaterThan(cost1);
		});
	});

	describe('canUseAbility', () => {
		it('should return false when cannot afford', () => {
			state.money = 0;
			expect(canUseAbility(state, 'bot_streams')).toBe(false);
		});

		it('should return true when can afford', () => {
			expect(canUseAbility(state, 'bot_streams')).toBe(true);
		});

		it('should return false when already active', () => {
			useAbility(state, 'bot_streams');
			expect(canUseAbility(state, 'bot_streams')).toBe(false);
		});
	});

	describe('useAbility', () => {
		it('should create active boost', () => {
			const result = useAbility(state, 'bot_streams');
			expect(result).toBe(true);
			expect(state.activeBoosts.length).toBe(1);
		});

		it('should deduct cost', () => {
			const initialMoney = state.money;
			const ability = getAbility('bot_streams')!;
			const cost = calculateAbilityCost(ability, 0);

			useAbility(state, 'bot_streams');
			expect(state.money).toBe(initialMoney - cost);
		});

		it('should set correct boost properties', () => {
			const ability = getAbility('bot_streams')!;
			useAbility(state, 'bot_streams');

			const boost = state.activeBoosts[0];
			expect(boost.abilityId).toBe('bot_streams');
			expect(boost.multiplier).toBe(ability.multiplier);
			expect(boost.type).toBe(ability.type);
		});

		it('should fail when cannot use', () => {
			state.money = 0;
			const result = useAbility(state, 'bot_streams');
			expect(result).toBe(false);
		});
	});

	describe('processBoosts', () => {
		it('should remove expired boosts', () => {
			useAbility(state, 'bot_streams');

			// Expire the boost
			state.activeBoosts[0].expiresAt = Date.now() - 1000;

			processBoosts(state);
			expect(state.activeBoosts.length).toBe(0);
		});

		it('should keep active boosts', () => {
			useAbility(state, 'bot_streams');
			processBoosts(state);
			expect(state.activeBoosts.length).toBe(1);
		});
	});

	describe('getBoostMultiplier', () => {
		it('should return 1.0 with no active boosts', () => {
			const multiplier = getBoostMultiplier(state, 'income');
			expect(multiplier).toBe(1.0);
		});

		it('should return ability multiplier', () => {
			const ability = getAbility('bot_streams')!;
			useAbility(state, 'bot_streams');

			const multiplier = getBoostMultiplier(state, 'income');
			expect(multiplier).toBe(ability.multiplier);
		});

		it('should multiply multiple boosts', () => {
			useAbility(state, 'bot_streams'); // 2x income
			useAbility(state, 'viral_marketing'); // 4x income

			const multiplier = getBoostMultiplier(state, 'income');
			expect(multiplier).toBe(8.0); // 2 * 4
		});
	});

	describe('getActiveBoosts', () => {
		it('should return all active boosts', () => {
			useAbility(state, 'bot_streams');
			useAbility(state, 'playlist_placement');

			const boosts = getActiveBoosts(state);
			expect(boosts.length).toBe(2);
		});

		it('should filter by type', () => {
			useAbility(state, 'bot_streams'); // income
			useAbility(state, 'playlist_placement'); // fans

			const incomeBoosts = getActiveBoosts(state, 'income');
			expect(incomeBoosts.length).toBe(1);
			expect(incomeBoosts[0].type).toBe('income');
		});
	});
});
